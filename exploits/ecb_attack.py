# ecb_attack.py - exploit/demo script for the vulnerable AES-ECB lab
# - Detects repeated 16-byte ciphertext blocks (ECB pattern leakage)
# - Brute-forces a 4-digit PIN used as the AES key (PIN repeated to 16 bytes)
# - Reports how many attempts the brute-force took
# - Demonstrates cut-and-paste tampering by swapping ciphertext blocks (no key needed to tamper)

from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from collections import defaultdict

CIPHERFILE = "vuln_email_ecb.bin"
MARKER = b"SECRET:"   # known marker used in the vulnerable plaintext
BLOCK_SIZE = 16

def load_ciphertext(path):
    with open(path, "rb") as f:
        return f.read()

def split_blocks(data, size=BLOCK_SIZE):
    return [data[i:i+size] for i in range(0, len(data), size)]

def find_repeated_blocks(ciphertext):
    blocks = split_blocks(ciphertext)
    idx_by_block = defaultdict(list)
    for i, b in enumerate(blocks):
        idx_by_block[b.hex()].append(i)
    repeated = {h: idxs for h, idxs in idx_by_block.items() if len(idxs) > 1}
    return repeated

def brute_force_pin_with_count(ciphertext, marker=MARKER):
    """
    Try every 4-digit PIN (0000-9999). Count attempts and return:
      (pin, key, plaintext, attempts)
    or (None, None, None, attempts) if not found after 10k tries.
    """
    attempts = 0
    for i in range(10000):
        attempts += 1
        pin = f"{i:04d}"
        key = (pin.encode() * 4)[:16]
        cipher = AES.new(key, AES.MODE_ECB)
        decrypted_raw = cipher.decrypt(ciphertext)
        if marker in decrypted_raw:
            # attempt to unpad for nicer output; fallback to raw bytes
            try:
                plaintext = unpad(decrypted_raw, BLOCK_SIZE)
            except ValueError:
                plaintext = decrypted_raw
            return pin, key, plaintext, attempts
    return None, None, None, attempts

def tamper_swap_blocks(ciphertext, idx_a, idx_b):
    blocks = split_blocks(ciphertext)
    if idx_a < 0 or idx_b < 0 or idx_a >= len(blocks) or idx_b >= len(blocks):
        raise IndexError("block indices out of range")
    tampered = blocks.copy()
    tampered[idx_a], tampered[idx_b] = tampered[idx_b], tampered[idx_a]
    return b"".join(tampered)

def pretty_print_repeated(repeated_map):
    if not repeated_map:
        print("No repeated 16-byte ciphertext blocks detected.")
        return
    print("Detected repeated ciphertext blocks (hex -> indices):")
    for h, idxs in repeated_map.items():
        print(f"  {h} -> {idxs}")

def main():
    try:
        ct = load_ciphertext(CIPHERFILE)
    except FileNotFoundError:
        print("ERROR: ciphertext file not found. Run the vulnerable generator first.")
        return

    print("1) ECB pattern analysis:")
    repeated = find_repeated_blocks(ct)
    pretty_print_repeated(repeated)
    if repeated:
        print("Note: repeated ciphertext blocks indicate identical 16-byte plaintext blocks under ECB.\n")
    else:
        print("No repeated-block pattern found in this ciphertext.\n")

    print("2) Brute-forcing 4-digit PIN (0000-9999)...")
    pin, key, plaintext, attempts = brute_force_pin_with_count(ct)
    if pin is None:
        print(f"Brute-force failed after {attempts} attempts: no PIN in 0000-9999 produced plaintext containing the marker.")
        return

    print(f"\nBruteforce successful after: {attempts} attempts")
    print(f"Found PIN: {pin}")
    print("Derived key (hex):", key.hex())

    # --- Immediately decrypt and print the recovered plaintext after the key was found --- 
    print("\n== Decrypting ciphertext with recovered key (immediate output) ==\n")
    cipher = AES.new(key, AES.MODE_ECB)
    decrypted_raw = cipher.decrypt(ct)
    try:
        decrypted = unpad(decrypted_raw, BLOCK_SIZE)
    except ValueError:
        decrypted = decrypted_raw

    # print decoded text if possible, else show repr(bytes)
    print("Recovered plaintext (attempting to decode as UTF-8):\n")
    try:
        print(decrypted.decode())
    except Exception:
        # Not UTF-8 decodable; show a safe repr and also hex preview
        print(repr(decrypted))
        preview_len = min(160, len(decrypted))
        print("\nHex preview (first {} bytes):".format(preview_len))
        print(decrypted[:preview_len].hex())
    print("\n--- End recovered plaintext (immediate) ---\n")

    # Keep existing behavior: show number of blocks and demonstrate tampering
    blocks = split_blocks(ct)
    print(f"Ciphertext contains {len(blocks)} blocks (0..{len(blocks)-1}).")

    # Choose blocks to swap:
    if repeated:
        most_repeated_hex, idxs = max(repeated.items(), key=lambda kv: len(kv[1]))
        src_idx = idxs[0]
        target_idx = next((cand for cand in range(len(blocks)) if cand != src_idx), None)
        if target_idx is None:
            print("Not enough blocks to demonstrate swapping.")
            return
        a, b = src_idx, target_idx
    else:
        if len(blocks) >= 4:
            a, b = 2, 3
        elif len(blocks) >= 2:
            a, b = 0, 1
        else:
            print("Not enough blocks to demonstrate swapping.")
            return

    print(f"Tampering: swapping block {a} with block {b} (attacker does this without the key).")
    tampered_ct = tamper_swap_blocks(ct, a, b)
    tampered_file = "vuln_email_ecb_tampered_by_attacker.bin"
    with open(tampered_file, "wb") as f:
        f.write(tampered_ct)
    print("Tampered ciphertext written to:", tampered_file)

    # Decrypt tampered ciphertext with recovered key to show effect
    decrypted_tampered_raw = cipher.decrypt(tampered_ct)
    try:
        decrypted_tampered = unpad(decrypted_tampered_raw, BLOCK_SIZE)
    except ValueError:
        decrypted_tampered = decrypted_tampered_raw

    print("\nTampered plaintext (decoded if possible):\n")
    try:
        print(decrypted_tampered.decode())
    except Exception:
        print(repr(decrypted_tampered))
    print("\n--- End tampered plaintext ---\n")

    print("Summary:")
    print(" - Repeated ciphertext blocks (if any) reveal plaintext structure under ECB.")
    print(" - The 4-digit PIN-derived key was brute-forced; the script reports how many attempts it took.")
    print(" - An attacker can reorder ciphertext blocks (cut-and-paste) without knowing the key to alter the message.")
    
if __name__ == "__main__":
    main()
