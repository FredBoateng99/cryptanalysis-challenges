# exploit (not a file) - crib-drag + scoring exploit, wrapped as run_exploit()
import binascii, string, itertools
from pathlib import Path
from collections import defaultdict

PRINTABLE = set(bytes(string.printable, "ascii"))

def read_hex_file(path):
    s = Path(path).read_text().strip()
    return binascii.unhexlify(s)

def xor_bytes(a: bytes, b: bytes) -> bytes:
    return bytes(x ^ y for x, y in zip(a, b))

def is_mostly_printable(bs: bytes, threshold=0.9):
    good = sum(1 for c in bs if c in PRINTABLE)
    return (good / max(1, len(bs))) >= threshold

def crib_drag_single(xor_p: bytes, crib: bytes, min_print_frac=0.85):
    results = []
    L = len(xor_p)
    if len(crib) == 0: return results
    for pos in range(0, L - len(crib) + 1):
        frag = bytes(a ^ b for a, b in zip(crib, xor_p[pos:pos+len(crib)]))
        if is_mostly_printable(frag, threshold=min_print_frac):
            results.append((pos, frag))
    return results

def score_plaintext_candidate(bs: bytes):
    s = 0.0
    printable_frac = sum(1 for c in bs if c in PRINTABLE) / max(1, len(bs))
    s += printable_frac * 10.0
    txt = bs.decode('ascii', errors='ignore').lower()
    common = ['acct', 'txn', 'amt', 'date', 'ref', 'alert', 'payment', 'wire', 'confirm', 'balance', 'low', 'transfer', 'from', 'to']
    for w in common:
        s += 2.0 * txt.count(w)
    s -= 1.0 * sum(1 for c in bs if c < 32 or c > 126)
    return s

def pairwise_xors(cts):
    pairs = {}
    for i, j in itertools.combinations(range(len(cts)), 2):
        pairs[(i, j)] = xor_bytes(cts[i], cts[j])
    return pairs

def automated_crib_search(ciphertexts, cribs, top_k=30):
    pairs = pairwise_xors(ciphertexts)
    placements = defaultdict(list)
    for (i, j), xor_p in pairs.items():
        candidates = []
        for crib in cribs:
            hits = crib_drag_single(xor_p, crib.encode(), min_print_frac=0.85)
            for pos, frag in hits:
                score = (score_plaintext_candidate(crib.encode()) + score_plaintext_candidate(frag)) / 2.0
                candidates.append((score, crib, pos, frag))
        candidates.sort(reverse=True, key=lambda x: x[0])
        placements[(i, j)] = candidates[:top_k]
    return placements

def overlay_fragments(length, fragment_placements):
    out = bytearray(b'?' * length)
    for idx, pos, frag in fragment_placements:
        for k, b in enumerate(frag):
            if pos + k >= length: break
            if out[pos + k] == ord('?'):
                out[pos + k] = b
    return bytes(out)

def run_exploit(show_full_recovery_with_saved_key=True):
    # Read ciphertexts written by run_vulnerable()
    cpaths = ["ciphertext1.hex", "ciphertext2.hex", "ciphertext3.hex", "ciphertext4.hex"]
    ciphertexts = []
    for p in cpaths:
        if not Path(p).exists():
            raise FileNotFoundError(f"Missing {p} — run the vulnerable cell first.")
        ciphertexts.append(read_hex_file(p))
    print("exploit: Loaded", len(ciphertexts), "ciphertexts. Lengths:", [len(c) for c in ciphertexts])

    cribs = [
        "TXN:", "TRANSFER", "PAYMENT", "WIRE", "ALERT", "LOW_BAL", "ACCT:", "AMT:", "DATE:", "REF:",
        "FAKE-ACCT", "MERCHANT", "ORDER", "Payroll", "CONF:", "BAL:", "ACTION:", "Deposit", "Fee",
        "PayrollNov", "CapitalMove", "ORDER#A1234", "2025", "11-01", "11-02"
    ] + ["FROM:", "TO:", "AMT", "$", "REF"]

    placements = automated_crib_search(ciphertexts, cribs, top_k=25)

    # Print top hits for each pair
    for (i, j), hits in placements.items():
        print(f"\nPair ciphertext {i+1} ^ {j+1} — top hits:")
        for score, crib, pos, frag in hits[:8]:
            frag_text = frag.decode('ascii', errors='replace')
            print(f" score={score:.2f} crib='{crib}' at pos={pos} -> fragment: '{frag_text}'")

    # Attempt overlayed reconstructions
    length = max(len(c) for c in ciphertexts)
    fragment_placements = []
    for (i, j), hits in placements.items():
        for score, crib, pos, frag in hits[:5]:
            fragment_placements.append((i, pos, crib.encode()))
            fragment_placements.append((j, pos, frag))

    reconstructions = []
    for m in range(len(ciphertexts)):
        frags_for_m = [(idx, pos, frag) for (idx, pos, frag) in fragment_placements if idx == m]
        recon = overlay_fragments(length, [(idx, pos, frag) for (idx, pos, frag) in frags_for_m])
        reconstructions.append(recon)

    for i, rec in enumerate(reconstructions):
        print(f"\nReconstruction for message {i+1} (unknowns shown as '?'):\n{rec.decode(errors='replace')}\n")

    if show_full_recovery_with_saved_key:
        try:
            key = read_hex_file("reused_key.hex")
            print("=== Full recovery using saved key (DEMO ONLY) ===")
            for i, ct in enumerate(ciphertexts):
                pt = bytes(a ^ b for a, b in zip(ct, key[:len(ct)]))
                print(f"Plaintext {i+1}:", pt.decode(errors='replace'))
        except FileNotFoundError:
            print("Saved key not found; full recovery demonstration skipped.")

    return {"placements_count": sum(len(v) for v in placements.values())}
